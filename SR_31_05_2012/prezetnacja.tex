\documentclass{beamer}
\usetheme{Warsaw}

\usepackage{polski}
\usepackage[latin2]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{multirow}

\title{TinyOS 2.0}

\subtitle{Nowa era programowania mikrourz±dzeñ} % (optional)

\author % (optional, use only with lots of authors)
{Przemys³aw Horban, Jacek Migda³}

\institute{Uniwersytet Warszawski}
\date[Short Occasion] % (optional)
% {Date / Occasion}

\subject{Talks}
% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
% \AtBeginSubsection[]
% {
%   \begin{frame}<beamer>{Outline}
%     \tableofcontents[currentsection,currentsubsection]
%   \end{frame}
% }


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

% \beamerdefaultoverlayspecification{<+->}

\newcommand{\car}{\textasciicircum}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Port TinyOS na chronos}
  Nasza praca magisterska to port TinyOS na zegarki ez430 (chronos)
  \begin{itemize}
    \item napisanie sterowników do obs³ugi sprzêtu
    \item stworzenie wygodnego ¶rodowiska programistycznego
  \end{itemize}
\end{frame}

\begin{frame}{}
  \huge{ Po³±czyli¶my w sieæ komputery, komórki... ale co z reszt± urz±dzeñ? }
\end{frame}

\begin{frame}{Potrzebujemy nowej klasy urz±dzeñ}
  Potrzebujemy nowej klasy urz±dzeñ:
  \begin{itemize}
    \item tanich
    \item "gadaj±cych" po radiu
    \item wytrzymuj±cych lata na bateriach - ultra niski duty cycle
  \end{itemize}
\end{frame}

\begin{frame}{Przyk³ady}
  Przyk³ady:
  \begin{itemize}
    \item Smart Grid
    \item sterowanie ruchem ulicznym
    \item monitorowanie zasobów
  \end{itemize}
\end{frame}


\begin{frame}{Hardware}
  Zegarek Chronoz ez-430:
  \begin{itemize}
    \item flash: 32 KB flash
    \item ram:    4 KB
    \item cpu:    20 MHz msp430
    \item sensory: akcelerometr, temperatura, ci¶nienie
    \item radio:  867 MHz (~90 metrów, ~12 KB realnego transferu)
    \item dodatowo: ekran LCD, przyciski
  \end{itemize}
\end{frame}

\begin{frame}{Software}
  Jak programowaæ
  \begin{itemize}
    \item Producent do³±cza system chronos...
    \item W jêzyku C z dodatkowymi definicjami.
    \item Wszystko trzeba robiæ rêcznie, ustawiaæ warto¶ci itp.
    \item Debugowanie i testowanie to koszmar.
  \end{itemize}
\end{frame}

% Przyk³ad


\begin{frame}{Sterowniki w chronos}
  \begin{itemize}
    \item Pliki .c .h, które udostêpniaj± parê funkcji
    \item Niestety s± singletonem, nie maj± ¿adnej kontroli dostêpu.
    \item Problem braku inicjalizacji, podwójnej inicjalizacji, konflikt w dostêpie do zasobów...
  \end{itemize}
\end{frame}




\begin{frame}{TinyOS 1.0}
  Zalety:
  \begin{itemize}
    \item nadaje aplikacji strukturê
    \item daje za darmo zarz±dzanie zdaniami i~tym samym sposób my¶lenia na którym mo¿na siê oprzeæ
    \item dziêki interfejsom architektury HAA zapewnia przeno¶no¶æ wielu aplikacji miêdzy platformami
    \item pozwala ³±czyæ ze sob± protoko³y i~algorytmy wynalezione przez ró¿ne grupy (LPL, CTP, Tricle)
    \item pozostawia wielk± elastyczno¶æ programi¶cie (to wci±¿ C)
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 1.0}
  Wady:
  \begin{itemize}
    \item du¿e problemy z~zarz±dzaniem pamiêci± (crash gdy jej zabraknie)
    \item czêste b³êdy przy wspó³bie¿no¶ci, ze wzglêdu na przeploty z~przerwaniami
    \item b³êdy podwójnej lub zapomnianej inicjalizacji
    \item trudne do ogarniêcia zale¿no¶ci miêdzy komponentami
    \item oddzielna kompilacja utrudnia statyczn± analizê
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 1.0}
  Wnioski:
  \begin{itemize}
    \item mo¿na by du¿o skorzystaæ, gdyby poczyniæ pewnie silniejsze za³o¿enia
      o~jêzyku programowania i~zarz±dzaniu zasobami
    \item potrzeba wiêkszej hermetyzacji modu³ów oraz ³atwiejszego sposobu
      organizowania zale¿no¶ci miêdzy modu³ami
    \item przydatna by³a by statyczna analiza kodu aplikacji
    \item ogólnie, bardzo potrzebne by³o lepsze wsparcie narzêdziowe
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 1.0}

  {\bf nesC } nadziej± na rozwi±zanie powy¿szych problemów.
\end{frame}

\begin{frame}{TinyOS 2.0}
  Najwa¿niejsze cechy:
  \begin{itemize}
    \item rozwi±zuje problemy rozpoznane przy pracy z~TinyOS 1.0
    \item pamiêæ alokowana ca³kowicie statycznie, w~czasie kompilacji
    \item statyczna analiza przeplotów wykonania wspó³bie¿nego~generowanie
      ostrze¿eñ w~czasie kompilacji
    \item automatyczna inicjalizacja wci±ganych komponentów
    \item statyczna analiza inicjalizacji (@once)
    \item przejrzyste granice miêdzy komponentami, wyznaczone przez interfejsy
    \item mo¿liwo¶æ dog³êbnej analizy i~optymalizacji kodu
    \item wykorzystanie dorobku w~dziedzinie kompilatorów
  \end{itemize}
\end{frame}


\begin{frame}{nesC}
   Czê¶æ funkcjonalno¶ci TinyOS realizuje kompilator nesC:
   \begin{itemize}
     \item nesC: rozszerzenie C, jest te¿ kompilowane do C
     \item wielow±tkowo¶æ bez wyw³aszczeñ
     \item statyczna 'obiektowo¶æ' - na poziomie kompilacji
%     \item zdarzenia, polecenia i zadania
  \end{itemize}
\end{frame}

\begin{frame}{nesC - organizacja kodu}
	Organizacja kodu:
   \begin{itemize}
   	 \item dwukierunkowy zbiór sygnatur funkcji - interfejs
   	 \begin{itemize}
   	    \item zdarzenie (event)
   	    \item zadanie (task)
   	    \item polecenie (command)
   	 \end{itemize}
     \item kod C - modu³y
     \begin{itemize}
     	\item wykorzystujê i dostarcza interfejsów
     \end{itemize}
     \item ³±czenie wielu komponentów w jeden - konfiguracja
%     \item zdarzenia, polecenia i zadania
  \end{itemize}
\end{frame}

\begin{frame}{Pojêcie hermetycznego komponentu}
  \begin{itemize}
    \item MainC
      \begin{itemize}
        \item zawo³am wszystkie metody init() interfejsów Init
        \item zawo³am potem zawo³am metody boot() interfejsów Boot
        \item wywo³am pêtlê zadañ
      \end{itemize}

    \item PlatformLCDC
      \begin{itemize}
        \item pod³±czê wewnêtrzn± inicjalizacjê do MainC
        \item dajê interfejs LCDDriver
      \end{itemize}

    \item SerialActiveMessageC
      \begin{itemize}
        \item wezmê PlatformSerialC, który zapewni mi interfejs UartStream
        \item w³±czê ca³y kod pakietowej obs³ugi portu szeregowego
        \item dam Ci interfejs AMSend z~metod± send()
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Hermetyczne komponenty}
  \begin{itemize}
    \item platforma dostarcza kilkana¶cie komponentów do obs³ugi urz±dzeñ
    \item biblioteki TOS dostarczaj± swoje komponenty z~us³ugami wy¿szego poziomu
    \item aplikacje (bêd±ce komponentami) dostarczaj± komponenty implementuj±ce
      logikê
  \end{itemize}
  Bierzemy wiêc odpowiednie pude³ka, ³±czymy je w~konfiguracji i~uzyskujemy
  dzia³aj±cy program.
\end{frame}

\begin{frame}{Wy¶wietlacz PC -> LCD}
  To jest aplikacja!

  \tt{components MainC, SerialActiveMessageC;}

  \tt{components PlatformLCDC, PC2LCDAppP; }

  \tt{PC2LCDAppP.Boot      -> MainC; }

  \tt{PC2LCDAppP.AMSend    -> SerialActiveMessageC; }

  \tt{PC2LCDAppP.LCDDriver -> PlatformLCDC; }
\end{frame}

\begin{frame}{Case study: Virtualized timers}
  Pierwszy przyk³ad - tyle zegarów ile tylko chcemy!
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Problem:
  \begin{figure} [ht]
    \centering
    \includegraphics[width=\linewidth]{problem.png}
  \end{figure}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  \begin{itemize}
    \item trzeba rozwi±zaæ konflikty o~zasoby
    \item ale równie¿ oszczêdzaæ energiê, gdy zasób nie jest u¿ywany
  \end{itemize}
  Okazuje siê, ¿e oba problemy s± maj± wspólne rozwi±zanie.
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}

  \tt{interface Resource \{ }

  \tt{ \hspace{4 mm} async command error\_t request(); }
  
  \tt{ \hspace{4 mm} event void granted(); }

  \tt{ \hspace{4 mm} async command error\_t release(); }

  \tt{ \hspace{4 mm} async command bool isOwner(); }

  \tt{ \} }

\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Rozwi±zanie:
  \begin{figure} [ht]
    \centering
    \includegraphics[height=0.7 \textheight]{rozwiazanie.png}
  \end{figure}
\end{frame}

\begin{frame}{Case study: Zordon App}
  \tt{
  components MainC, ZordonP as App;

  components PlatformLCDC;

  components new AMSenderC(RANGER\_CALL\_MSG);

  components new AMReceiverC(RANGER\_CALL\_MSG);

  components ActiveMessageC;
 
  App.Boot -> MainC;

  App.LCDDriver -> PlatformLCDC;

  App.AMSend -> AMSenderC;

  App.Receive -> AMReceiverC;

  App.AMControl -> ActiveMessageC;
  }
\end{frame}

\begin{frame}{Case study: Zordon App}
  \tt {
  components UpButtonC, DownButtonC;

  components BacklightButtonC, StarButtonC;

  App.NextNameButton -> UpButtonC;

  App.PowerButton -> BacklightButtonC;

  App.PrevNameButton -> DownButtonC;

  App.SendButton -> StarButtonC;

  components BeeperC;

  App.Beeper -> BeeperC;

  components TopLCDBlinkerC;

  App.TopBlinkerControl -> TopLCDBlinkerC;

  App.TopLCDBlinker -> TopLCDBlinkerC;
  }
\end{frame}


% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\end{document}

