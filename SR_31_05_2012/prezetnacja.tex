\documentclass{beamer}
\usetheme{Warsaw}

\usepackage{polski}
\usepackage[latin2]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{multirow}

\title{TinyOS 2.0}

\subtitle{Nowa era programowania mikrourz±dzeñ} % (optional)

\author % (optional, use only with lots of authors)
{Przemys³aw Horban, Jacek Migda³}

\institute{Uniwersytet Warszawski}
\date[Short Occasion] % (optional)
% {Date / Occasion}

\subject{Talks}
% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
% \AtBeginSubsection[]
% {
%   \begin{frame}<beamer>{Outline}
%     \tableofcontents[currentsection,currentsubsection]
%   \end{frame}
% }


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

% \beamerdefaultoverlayspecification{<+->}

\newcommand{\car}{\textasciicircum}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Zegarki eZ430-Chronos}
  \begin{figure} [ht]
    \centering
    \includegraphics[width=0.3 \linewidth]{ez430-chronos.jpeg}
  \end{figure}
  \begin{itemize}
    \item architektura MSP430
    \item pracujemy nad przeniesieniem TinyOS na t± platformê
    \item s± one ju¿ zakupione i~mamy ich du¿o
    \item nasza praca pozwoli nastêpnym studentom w~pe³ni wykorzystaæ ich
      mo¿liowo¶ci (sterowniki, wygodne ¶rodowisko programistyczne)
  \end{itemize}
\end{frame}

\begin{frame}{Co potrafi taki zegarek i~jaki jest stan prac}
  \begin{center}
    \LARGE
    \emph{Demo}
  \end{center}
\end{frame}

\begin{frame}{Hardware zegarka}
  \begin{itemize}
    \item Procesor 20 MHz
    \item 4KB RAM
    \item 32KB flash (pamiêæ programu)
    \item Radio 868 MHz (transmisja 11 KB/s)
    \item Wy¶wietlacz LCD (4 +~5 cyfr oraz ikonki)
    \item Port szeregowy - UART (printf do PC itp.)
    \item Akcelerometr 3D
    \item Miernik ci¶nienia
    \item 5 przycisków
  \end{itemize}
\end{frame}

\begin{frame}{}
  \huge{ Po³±czyli¶my w sieæ komputery, komórki... ale co z reszt± urz±dzeñ? }
\end{frame}

\begin{frame}{Potrzebujemy nowej klasy urz±dzeñ}
  Potrzebujemy nowej klasy urz±dzeñ:
  \begin{itemize}
    \item tanich
    \item "gadaj±cych" po radiu
    \item wytrzymuj±cych lata na bateriach - ultra niski duty cycle
  \end{itemize}
\end{frame}

\begin{frame}{Przyk³ady}
  \begin{columns}
    \begin{column}[l]{5cm}
      Przyk³ady:
      \begin{itemize}
        \item Smart Grid
        \item sterowanie ruchem ulicznym
        \item monitorowanie zasobów
      \end{itemize}
    \end{column}
    \begin{column}[r]{5cm}

      \begin{figure} [ht]
        \centering
        \includegraphics[height=0.7 \textheight]{Internet-of-the-things.jpg}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Software}
  Jak programowaæ
  \begin{itemize}
    \item Producent do³±cza system chronos...
    \item W jêzyku C z dodatkowymi definicjami.
    \item Wszystko trzeba robiæ rêcznie, ustawiaæ warto¶ci itp.
    \item Debugowanie i testowanie to koszmar.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Przyk³ad kodu Texas Instruments}
\begin{verbatim}
 24 #include "msp430x22x4.h"
 25 
 26 void main(void)
 27 {
 28   WDTCTL = WDT_ADLY_250;                    
 29   IE1 |= WDTIE;                             
 30   P1DIR |= 0x01;                           
 31 
 32   __bis_SR_register(LPM3_bits + GIE);       
 33 }
 34 
 35 // Watchdog Timer interrupt service routine
 36 #pragma vector = WDT_VECTOR
 37 __interrupt void watchdog_timer(void)
\end{verbatim}
\end{frame}

\begin{frame}{Sterowniki w chronos}
  \begin{itemize}
    \item Pliki .c .h, które udostêpniaj± parê funkcji
    \item Niestety s± singletonem, nie maj± ¿adnej kontroli dostêpu.
    \item Problem braku inicjalizacji, podwójnej inicjalizacji, konflikt w dostêpie do zasobów...
  \end{itemize}
\end{frame}

\begin{frame}{Rozwi±zanie}
  \begin{itemize}
    \item TinyOS jest systemem powsta³ym z~my¶l± o~tych problemach
    \item Aby im zaradziæ potrzeba by³o nowych narzêdzi - a~w~szczególno¶ci nowego jêzyka: \emph{nesC}
  \end{itemize}
\end{frame}

\begin{frame}{nesC}
   Czê¶æ funkcjonalno¶ci TinyOS realizuje kompilator nesC:
   \begin{itemize}
     \item nesC: rozszerzenie C, jest te¿ kompilowane do C
     \item wielow±tkowo¶æ bez wyw³aszczeñ
     \item statyczna 'obiektowo¶æ' - na poziomie kompilacji
%     \item zdarzenia, polecenia i zadania
  \end{itemize}
\end{frame}

\begin{frame}{nesC - organizacja kodu}
	Organizacja kodu:
   \begin{itemize}
   	 \item dwukierunkowy zbiór sygnatur funkcji - interfejs
   	 \begin{itemize}
   	    \item zdarzenie (event)
   	    \item zadanie (task)
   	    \item polecenie (command)
   	 \end{itemize}
     \item kod C - modu³y
     \begin{itemize}
     	\item wykorzystujê i dostarcza interfejsów
     \end{itemize}
     \item ³±czenie wielu komponentów w jeden - konfiguracja
%     \item zdarzenia, polecenia i zadania
  \end{itemize}
\end{frame}


\begin{frame}{TinyOS 2.0}
  Jak to dzia³a?
  \begin{itemize}
    \item Gdzie¶ w~kodzie (komponent MainC) startuje funkcja main() - dla nas niewidoczna
    \item Wywo³uje ona metody interfejsów Init i~Boot
    \item W~ten sposób inicjalizowane s± urz±dzenia i~dane aplikacji
    \item Dalej wykonuj± siê ju¿ tylko przerwania i~pêtla schedulera
    \item Przerwania generuje np. zegar (\emph{event Timer.fired()})
    \item Task  dla schedulera to funkcja \emph{void f(void)}
    \item Kod, np. w~trakcie obs³ugi przerwania, zleca wykonanie tasku wywo³aniem \emph{post zadanie()}
    \item Praca TinyOS to ci±g³a obs³uga przerwañ i~wykonywanie task'ów
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 2.0}
  Najwa¿niejsze zalety:
  \begin{itemize}
    \item Rozwi±zuje problemy zarz±dzania pamiêci± dziêki ca³kowicie statycznej alokacji
    \item Dba o~poprawn± inicjalizacjê u¿ytych komponentów (@once i~automatyzacja)
    \item Porz±dkuje wykonanie g³ównego (scheduler) i~obs³ugê przerwañ
    \item Zapewnia statyczn± analizê przeplotów i~ostrzega o~wy¶cigach do zasobów
    \item Dostarcza spójnych i~hermetycznych komponentów, które s± ³atwe w~u¿yciu
    \item Bardzo upraszcza zarz±dzanie zale¿no¶ciami miêdzy komponentami
    \item Umo¿liwia statyczn± analizê kodu ca³ej aplikacji
    \item Nie marnuje dorobku w~zakresie kompilatorów
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 2.0}
  Zalety zwi±zane ze struktur± kodu:
  \begin{itemize}
    \item U³atwia my¶lenie i~projektowanie dostarczaj±c gotowej struktury systemu
    \item Dostarcza i~wspera wiele platform wspó³dziel±cych jedn± bazê kodu
    \item Umo¿liwia powstawanie interfejsów wysokiego poziomu (HAA)
    \item Sprawia, ¿e implementacje algorytmów opracowywanych przez ró¿ne grupy mog±
      byæ u¿yte w~jednej aplikacji

      \begin{itemize}
        \item Low power listening
        \item TRICLE
        \item Collection tree protocol
      \end{itemize}

    \item Dostarcza wielu bibliotek, ³atwych i~gotowych do u¿ycia przy nowych platformach
    \item Ma bardzo przyjazn± licencjê
  \end{itemize}
\end{frame}


\begin{frame}{Pojêcie hermetycznego komponentu}
  Jest to co¶ co bardzo u³atwia pracê programisty.
  \begin{itemize}
    \item MainC
      \begin{itemize}
        \item wo³a metody init() interfejsów Init
        \item wo³a metody boot() interfejsów Boot
        \item wchodzi pêtlê task schedulera
      \end{itemize}

    \item PlatformLCDC
      \begin{itemize}
        \item pod³±cza wewnêtrzn± inicjalizacjê do MainC
        \item inicjalizuje kontroler LCD
        \item dostarcza interfejs LCDDriver
      \end{itemize}

    \item SerialActiveMessageC
      \begin{itemize}
        \item bierze z~platformy PlatformSerialC, który dostarcza interfejs UartStream
        \item pod³±cza kod pakietowej obs³ugi portu szeregowego
        \item dostarcza m. in. interfejs AMSend z~metod± send()
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Obszary systemu TinyOS}
  \begin{itemize}
    \item Platforma dostarcza kilkana¶cie komponentów do obs³ugi urz±dzeñ (np. strumieñ bajtów)
    \item Biblioteki TOS dostarczaj± swoje komponenty z~us³ugami wy¿szego poziomu (np. transmisja pakietowa)
    \item Aplikacje dostarczaj± modu³y implementuj±ce logikê aplikacji
  \end{itemize}
  Elementy te zbierane s± razem i~³±czone za pomoc± konfiguracji, w~efekcie czego uzyskujemy
  dzia³aj±cy program.
\end{frame}

\begin{frame}{Przyk³ad: wy¶wietlacz PC -> LCD}
  To jest aplikacja!

  \tt{components MainC, SerialActiveMessageC;}

  \tt{components PlatformLCDC, PC2LCDAppP; }

  \tt{PC2LCDAppP.Boot      -> MainC; }

  \tt{PC2LCDAppP.AMSend    -> SerialActiveMessageC; }

  \tt{PC2LCDAppP.LCDDriver -> PlatformLCDC; }
\end{frame}

\begin{frame}{Case study: Virtualized timers}
  Problem:
  \begin{itemize}
    \item Sterowanie urz±dzeniem wymaga zegarów. Potrzebujemy ich du¿o.
    \item Mamy ich ma³o (zazwyczaj 3).
  \end{itemize}
  Rozwi±zanie:
  \begin{itemize}
    \item Wirtualizacja:
    \begin{itemize}
      \item TinyOS dostarcza generyczny komponent zegara: TimerMilliC
      \item Mo¿emy mieæ wiele instacji jego i~u¿ywaæ go jako zegara sprzêtowego.
      \item Jest Singleton, który kontrolujê dostêp do sprzêtu. 
    \end{itemize}
    \item Alokujemy dok³adnie tyle zasobów ile potrzeba.
    \item Unikamy niepotrzebnych zale¿no¶ci pomiêdzy komponentami.
  \end{itemize}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Problem:
  \begin{figure} [ht]
    \centering
    \includegraphics[width=\linewidth]{problem.png}
  \end{figure}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Problem:
  \begin{itemize}
    \item Kilka szyn komunikacyjnych
    \item Ka¿da ma kilka urz±dzeñ, ale obs³ugiwaæ mo¿e tylko jedno
    \item Wszystko trzeba jeszcze w³±czaæ i~wy³±czaæ
  \end{itemize}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  \begin{itemize}
    \item Trzeba rozwi±zaæ konflikty o~zasoby
    \item ale równie¿ oszczêdzaæ energiê, gdy zasób nie jest u¿ywany
  \end{itemize}
  Okazuje siê, ¿e oba problemy s± maj± wspólne rozwi±zanie.
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}

  \tt{interface Resource \{ }

  \tt{ \hspace{4 mm} async command error\_t request(); }

  \tt{ \hspace{4 mm} event void granted(); }

  \tt{ \hspace{4 mm} async command error\_t release(); }

  \tt{ \hspace{4 mm} async command bool isOwner(); }

  \tt{ \} }

\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Rozwi±zanie:
  \begin{figure} [ht]
    \centering
    \includegraphics[height=0.7 \textheight]{rozwiazanie.png}
  \end{figure}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  \begin{itemize}
    \item Klient prosi o zasób
    \item Arbiter rozpatruje zapytania
    \item Je¶li urz±dzenie wy³±czone, konfiguruje je
    \item Power manager dba by procesor nie przeszed³ w zbyt g³êboki stan u¶pienia
    \item Klient dostaje urz±dzenie gotowe do dzia³ania
    \item Potem je zwalnia
    \item Gdy zabraknie ju¿ rz±dañ urz±dzenie jest wy³±czane
  \end{itemize}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  \begin{itemize}
    \item Os±ga to efektywno¶æ blisk± 99\% rêcznie dostrojonym rozwi±zaniom.
    \item Pamiêtajmy, ¿e chcemy mo¿liwie skróciæ czas gdy pr±do¿erne urz±dzenia
      s± w³±czone, wiêc ci±gle co¶ w³±czamy i wy³±czamy - a tu takiego kodu
      prawie nie ma
  \end{itemize}
\end{frame}

\begin{frame}{Case study: Zordon App}
  \tt{
  components MainC, ZordonP as App;

  components PlatformLCDC;

  components new AMSenderC(RANGER\_CALL\_MSG);

  components new AMReceiverC(RANGER\_CALL\_MSG);

  components ActiveMessageC;
 
  App.Boot -> MainC;

  App.LCDDriver -> PlatformLCDC;

  App.AMSend -> AMSenderC;

  App.Receive -> AMReceiverC;

  App.AMControl -> ActiveMessageC;
  }
\end{frame}

\begin{frame}{Case study: Zordon App}
  \tt {
  components UpButtonC, DownButtonC;

  components BacklightButtonC, StarButtonC;

  App.NextNameButton -> UpButtonC;

  App.PowerButton -> BacklightButtonC;

  App.PrevNameButton -> DownButtonC;

  App.SendButton -> StarButtonC;

  components BeeperC;

  App.Beeper -> BeeperC;

  components TopLCDBlinkerC;

  App.TopBlinkerControl -> TopLCDBlinkerC;

  App.TopLCDBlinker -> TopLCDBlinkerC;
  }
\end{frame}

\begin{frame}{S³owo o~debugowaniu}
  \begin{itemize}
    \item Wa¿nym probleme jest to, ¿e aplikacje jest do¶æ trudno debugowaæ
    \item Mamy funkcjê printf
    \item Dla Chronos'a dzia³a nawet debugger w~Eclipse!
  \end{itemize}
  Najczêstrzy przypadek jest i~tak taki: Mia³a ¶wieciæ dioda. Wgrywamy - nie
  ¶wieci. I~co?

  Piotr opowie wiêcej jak temu zaradziæ.
\end{frame}


% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\end{document}

