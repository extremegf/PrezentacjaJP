\documentclass{beamer}
\usetheme{Warsaw}

\usepackage{polski}
\usepackage[latin2]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{multirow}

\title{TinyOS 2.0}

\subtitle{Nowa era programowania mikrourz±dzeñ} % (optional)

\author % (optional, use only with lots of authors)
{Przemys³aw Horban i~Jacek Migda³}

\institute{Uniwersytet Warszawski}
\date[Short Occasion] % (optional)
% {Date / Occasion}

\subject{Talks}
% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
% \AtBeginSubsection[]
% {
%   \begin{frame}<beamer>{Outline}
%     \tableofcontents[currentsection,currentsubsection]
%   \end{frame}
% }


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

% \beamerdefaultoverlayspecification{<+->}

\newcommand{\car}{\textasciicircum}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Zegarki eZ430-Chronos}
  \begin{figure} [ht]
    \centering
    \includegraphics[width=0.3 \linewidth]{ez430-chronos.jpeg}
  \end{figure}
  \begin{itemize}
    \item architektura MSP430
    \item pracujemy nad przeniesieniem TinyOS na t± platformê
    \item s± one ju¿ zakupione i~mamy ich du¿o
    \item nasza praca pozwoli nastêpnym studentom w~pe³ni wykorzystaæ ich mo¿liowo¶ci
  \end{itemize}
\end{frame}

\begin{frame}{Co potrafi taki zegarek i~jaki jest stan prac}
  \begin{center}
    \LARGE
    \emph{Demo}
  \end{center}
\end{frame}

\begin{frame}{Hardware zegarka}
  \begin{itemize}
    \item Procesor 20 MHz
    \item 4KB RAM
    \item 32KB flash (pamiêæ programu)
    \item Radio 868 MHz (transmisja 11 KB/s)
    \item Wy¶wietlacz LCD (4 +~5 cyfr oraz ikonki)
    \item Port szeregowy - UART (printf do PC itp.)
    \item Akcelerometr 3D
    \item Miernik ci¶nienia
    \item 5 przycisków
  \end{itemize}
\end{frame}

\begin{frame}{Zasadniczy problem}
   ????problem zasadniczy - czas ¿ycia na bateriach i~zu¿ycie energii - to decyduje o~wszystskich kompromisach projektowych!??????????
\end{frame}

\begin{frame}{Tradycyjny sposób ich programowania}
  ??????????jak robi³o siê to zawsze - funkcja main(, wiele plików c, byæ mo¿e biblioteki. Piszemy swobodnie po rejestrach. Spore zamieszanie. Brak dostêpnych abstrakcji. Piszesz po rejestrach - wady powy¿szego podej¶cia: nieprzeno¶ne, ka¿dy kontroler musi miec osobny code base, utrudnia zrobienie uniwersalnych stosów siecowych, masa b³êdów wielokrotnego w³±czaenia, konflikty sprzêtowe, b³êdy dostêpu do pamiêci, ¶mieciaste aplikacje etc.)???
\end{frame}

\begin{frame}{Typowy kod}
  ??????????
\end{frame}

\begin{frame}{Rozwi±zanie}
  \begin{itemize}
    \item TinyOS jest systemem powsta³ym z~my¶l± o~tych problemach
    \item Aby im zaradziæ potrzeba by³o nowych narzêdzi - a~w~szczególno¶ci nowego jêzyka: \emph{nesC}
  \end{itemize}
\end{frame}

%--------------------------------------------------------------------------------
\begin{frame}{TinyOS 1.0}
  Zalety:
  \begin{itemize}
    \item nadaje aplikacji strukturê
    \item daje za darmo zarz±dzanie zdaniami i~tym samym sposób my¶lenia na którym mo¿na siê oprzeæ
    \item dziêki interfejsom architektury HAA zapewnia przeno¶no¶æ wielu aplikacji miêdzy platformami
    \item pozwala ³±czyæ ze sob± protoko³y i~algorytmy wynalezione przez ró¿ne grupy (LPL, CTP, Tricle)
    \item pozostawia wielk± elastyczno¶æ programi¶cie (to wci±¿ C)
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 1.0}
  Wady:
  \begin{itemize}
    \item du¿e problemy z~zarz±dzaniem pamiêci± (crash gdy jej zabraknie)
    \item czêste b³êdy przy wspó³bie¿no¶ci, ze wzglêdu na przeploty z~przerwaniami
    \item b³êdy podwójnej lub zapomnianej inicjalizacji
    \item trudne do ogarniêcia zale¿no¶ci miêdzy komponentami
    \item oddzielna kompilacja utrudnia statyczn± analizê
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 1.0}
  Wnioski:
  \begin{itemize}
    \item mo¿na by du¿o skorzystaæ, gdyby poczyniæ pewnie silniejsze za³o¿enia
      o~jêzyku programowania i~zarz±dzaniu zasobami
    \item potrzeba wiêkszej hermetyzacji modu³ów oraz ³atwiejszego sposobu
      organizowania zale¿no¶ci miêdzy modu³ami
    \item przydatna by³a by statyczna analiza kodu aplikacji
    \item ogólnie, bardzo potrzebne by³o lepsze wsparcie narzêdziowe
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 1.0}

  {\bf nesC } nadziej± na rozwi±zanie powy¿szych problemów.
\end{frame}

\begin{frame}{TinyOS 2.0}
  Najwa¿niejsze cechy:
  \begin{itemize}
    \item rozwi±zuje problemy rozpoznane przy pracy z~TinyOS 1.0
    \item pamiêæ alokowana ca³kowicie statycznie, w~czasie kompilacji
    \item statyczna analiza przeplotów wykonania wspó³bie¿nego~generowanie
      ostrze¿eñ w~czasie kompilacji
    \item automatyczna inicjalizacja wci±ganych komponentów
    \item statyczna analiza inicjalizacji (@once)
    \item przejrzyste granice miêdzy komponentami, wyznaczone przez interfejsy
    \item mo¿liwo¶æ dog³êbnej analizy i~optymalizacji kodu
    \item wykorzystanie dorobku w~dziedzinie kompilatorów
  \end{itemize}
\end{frame}

\begin{frame}{Pojêcie hermetycznego komponentu}
  \begin{itemize}
    \item MainC
      \begin{itemize}
        \item zawo³am wszystkie metody init() interfejsów Init
        \item zawo³am potem zawo³am metody boot() interfejsów Boot
        \item wywo³am pêtlê zadañ
      \end{itemize}

    \item PlatformLCDC
      \begin{itemize}
        \item pod³±czê wewnêtrzn± inicjalizacjê do MainC
        \item dajê interfejs LCDDriver
      \end{itemize}

    \item SerialActiveMessageC
      \begin{itemize}
        \item wezmê PlatformSerialC, który zapewni mi interfejs UartStream
        \item w³±czê ca³y kod pakietowej obs³ugi portu szeregowego
        \item dam Ci interfejs AMSend z~metod± send()
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Hermetyczne komponenty}
  \begin{itemize}
    \item platforma dostarcza kilkana¶cie komponentów do obs³ugi urz±dzeñ
    \item biblioteki TOS dostarczaj± swoje komponenty z~us³ugami wy¿szego poziomu
    \item aplikacje (bêd±ce komponentami) dostarczaj± komponenty implementuj±ce
      logikê
  \end{itemize}
  Bierzemy wiêc odpowiednie pude³ka, ³±czymy je w~konfiguracji i~uzyskujemy
  dzia³aj±cy program.
\end{frame}

\begin{frame}{Wy¶wietlacz PC -> LCD}
  To jest aplikacja!

  \tt{components MainC, SerialActiveMessageC;}

  \tt{components PlatformLCDC, PC2LCDAppP; }

  \tt{PC2LCDAppP.Boot      -> MainC; }

  \tt{PC2LCDAppP.AMSend    -> SerialActiveMessageC; }

  \tt{PC2LCDAppP.LCDDriver -> PlatformLCDC; }
\end{frame}

\begin{frame}{Case study: Virtualized timers}
  Pierwszy przyk³ad - tyle zegarów ile tylko chcemy!
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Problem:
  \begin{figure} [ht]
    \centering
    \includegraphics[width=\linewidth]{problem.png}
  \end{figure}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  \begin{itemize}
    \item trzeba rozwi±zaæ konflikty o~zasoby
    \item ale równie¿ oszczêdzaæ energiê, gdy zasób nie jest u¿ywany
  \end{itemize}
  Okazuje siê, ¿e oba problemy s± maj± wspólne rozwi±zanie.
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}

  \tt{interface Resource \{ }

  \tt{ \hspace{4 mm} async command error\_t request(); }
  
  \tt{ \hspace{4 mm} event void granted(); }

  \tt{ \hspace{4 mm} async command error\_t release(); }

  \tt{ \hspace{4 mm} async command bool isOwner(); }

  \tt{ \} }

\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Rozwi±zanie:
  \begin{figure} [ht]
    \centering
    \includegraphics[height=0.7 \textheight]{rozwiazanie.png}
  \end{figure}
\end{frame}

\begin{frame}{Case study: Zordon App}
  \tt{
  components MainC, ZordonP as App;

  components PlatformLCDC;

  components new AMSenderC(RANGER\_CALL\_MSG);

  components new AMReceiverC(RANGER\_CALL\_MSG);

  components ActiveMessageC;
 
  App.Boot -> MainC;

  App.LCDDriver -> PlatformLCDC;

  App.AMSend -> AMSenderC;

  App.Receive -> AMReceiverC;

  App.AMControl -> ActiveMessageC;
  }
\end{frame}

\begin{frame}{Case study: Zordon App}
  \tt {
  components UpButtonC, DownButtonC;

  components BacklightButtonC, StarButtonC;

  App.NextNameButton -> UpButtonC;

  App.PowerButton -> BacklightButtonC;

  App.PrevNameButton -> DownButtonC;

  App.SendButton -> StarButtonC;

  components BeeperC;

  App.Beeper -> BeeperC;

  components TopLCDBlinkerC;

  App.TopBlinkerControl -> TopLCDBlinkerC;

  App.TopLCDBlinker -> TopLCDBlinkerC;
  }
\end{frame}


% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\end{document}

