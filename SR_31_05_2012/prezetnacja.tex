\documentclass{beamer}
\usetheme{Warsaw}

\usepackage{polski}
\usepackage[latin2]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{multirow}

\title{TinyOS 2.0}

\subtitle{Nowa era programowania mikrourz±dzeñ} % (optional)

\author % (optional, use only with lots of authors)
{Przemys³aw Horban i~Jacek Migda³}

\institute{Uniwersytet Warszawski}
\date[Short Occasion] % (optional)
% {Date / Occasion}

\subject{Talks}
% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
% \AtBeginSubsection[]
% {
%   \begin{frame}<beamer>{Outline}
%     \tableofcontents[currentsection,currentsubsection]
%   \end{frame}
% }


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

% \beamerdefaultoverlayspecification{<+->}

\newcommand{\car}{\textasciicircum}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Zegarki eZ430-Chronos}
  \begin{figure} [ht]
    \centering
    \includegraphics[width=0.3 \linewidth]{ez430-chronos.jpeg}
  \end{figure}
  \begin{itemize}
    \item architektura MSP430
    \item pracujemy nad przeniesieniem TinyOS na t± platformê
    \item s± one ju¿ zakupione i~mamy ich du¿o
    \item nasza praca pozwoli nastêpnym studentom w~pe³ni wykorzystaæ ich mo¿liowo¶ci
  \end{itemize}
\end{frame}

\begin{frame}{Co potrafi taki zegarek i~jaki jest stan prac}
  \begin{center}
    \LARGE
    \emph{Demo}
  \end{center}
\end{frame}

\begin{frame}{Hardware zegarka}
  \begin{itemize}
    \item Procesor 20 MHz
    \item 4KB RAM
    \item 32KB flash (pamiêæ programu)
    \item Radio 868 MHz (transmisja 11 KB/s)
    \item Wy¶wietlacz LCD (4 +~5 cyfr oraz ikonki)
    \item Port szeregowy - UART (printf do PC itp.)
    \item Akcelerometr 3D
    \item Miernik ci¶nienia
    \item 5 przycisków
  \end{itemize}
\end{frame}

\begin{frame}{Zasadniczy problem}
   ????problem zasadniczy - czas ¿ycia na bateriach i~zu¿ycie energii - to decyduje o~wszystskich kompromisach projektowych!??????????

    % \item du¿e problemy z~zarz±dzaniem pamiêci± (crash gdy jej zabraknie)
    % \item czêste b³êdy przy wspó³bie¿no¶ci, ze wzglêdu na przeploty z~przerwaniami
    % \item b³êdy podwójnej lub zapomnianej inicjalizacji
    % \item trudne do ogarniêcia zale¿no¶ci miêdzy komponentami
    % \item oddzielna kompilacja utrudnia statyczn± analizê
\end{frame}

\begin{frame}{Tradycyjny sposób ich programowania}
  ??????????jak robi³o siê to zawsze - funkcja main(, wiele plików c, byæ mo¿e biblioteki. Piszemy swobodnie po rejestrach. Spore zamieszanie. Brak dostêpnych abstrakcji. Piszesz po rejestrach - wady powy¿szego podej¶cia: nieprzeno¶ne, ka¿dy kontroler musi miec osobny code base, utrudnia zrobienie uniwersalnych stosów siecowych, masa b³êdów wielokrotnego w³±czaenia, konflikty sprzêtowe, b³êdy dostêpu do pamiêci, ¶mieciaste aplikacje etc.)???
\end{frame}

\begin{frame}{Typowy kod}
  ??????????
\end{frame}

\begin{frame}{Rozwi±zanie}
  \begin{itemize}
    \item TinyOS jest systemem powsta³ym z~my¶l± o~tych problemach
    \item Aby im zaradziæ potrzeba by³o nowych narzêdzi - a~w~szczególno¶ci nowego jêzyka: \emph{nesC}
  \end{itemize}
\end{frame}

\begin{frame}nesC{}
  ?????????????
\end{frame}

\begin{frame}{TinyOS 2.0}
  Jak to dzia³a?
  \begin{itemize}
    \item Gdzie¶ w~kodzie (komponent MainC) startuje funkcja main() - dla nas niewidoczna
    \item Wywo³uje ona metody interfejsów Init i~Boot
    \item W~ten sposób inicjalizowane s± urz±dzenia i~dane aplikacji
    \item Dalej wykonuj± siê ju¿ tylko przerwania i~pêtla schedulera
    \item Przerwania generuje np. zegar (\emph{event Timer.fired()})
    \item Task  dla schedulera to funkcja \emph{void f(void)}
    \item Kod, np. w~trakcie obs³ugi przerwania, zleca wykonanie tasku wywo³aniem \emph{post zadanie()}
    \item Praca TinyOS to ci±g³a obs³uga przerwañ i~wykonywanie task'ów
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 2.0}
  Najwa¿niejsze zalety:
  \begin{itemize}
    \item Rozwi±zuje problemy zarz±dzania pamiêci± dziêki ca³kowicie statycznej alokacji
    \item Dba o~poprawn± inicjalizacjê u¿ytych komponentów (@once i~automatyzacja)
    \item Porz±dkuje wykonanie g³ównego (scheduler) i~obs³ugê przerwañ
    \item Zapewnia statyczn± analizê przeplotów i~ostrzega o~wy¶cigach do zasobów
    \item Dostarcza spójnych i~hermetycznych komponentów, które s± ³atwe w~u¿yciu
    \item Bardzo upraszcza zarz±dzanie zale¿no¶ciami miêdzy komponentami
    \item Umo¿liwia statyczn± analizê kodu ca³ej aplikacji
    \item Nie marnuje dorobku w~zakresie kompilatorów
  \end{itemize}
\end{frame}

\begin{frame}{TinyOS 2.0}
  Zalety zwi±zane ze struktur± kodu:
  \begin{itemize}
    \item U³atwia my¶lenie i~projektowanie dostarczaj±c gotowej struktury systemu
    \item Dostarcza i~wspera wiele platform wspó³dziel±cych jedn± bazê kodu
    \item Umo¿liwia powstawanie interfejsów wysokiego poziomu (HAA)
    \item Sprawia, ¿e implementacje algorytmów opracowywanych przez ró¿ne grupy mog±
      byæ u¿yte w~jednej aplikacji

      \begin{itemize}
        \item Low power listening
        \item TRICLE
        \item Collection tree protocol
      \end{itemize}

    \item Dostarcza wielu bibliotek, ³atwych i~gotowych do u¿ycia przy nowych platformach
    \item Ma bardzo przyjazn± licencjê
  \end{itemize}
\end{frame}

\begin{frame}{Pojêcie hermetycznego komponentu}
  Jest to co¶ co bardzo u³atwia pracê programisty.
  \begin{itemize}
    \item MainC
      \begin{itemize}
        \item wo³a metody init() interfejsów Init
        \item wo³a metody boot() interfejsów Boot
        \item wchodzi pêtlê task schedulera
      \end{itemize}

    \item PlatformLCDC
      \begin{itemize}
        \item pod³±cza wewnêtrzn± inicjalizacjê do MainC
        \item inicjalizuje kontroler LCD
        \item dostarcza interfejs LCDDriver
      \end{itemize}

    \item SerialActiveMessageC
      \begin{itemize}
        \item bierze z~platformy PlatformSerialC, który dostarcza interfejs UartStream
        \item pod³±cza kod pakietowej obs³ugi portu szeregowego
        \item dostarcza m. in. interfejs AMSend z~metod± send()
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Obszary systemu TinyOS}
  \begin{itemize}
    \item Platforma dostarcza kilkana¶cie komponentów do obs³ugi urz±dzeñ (np. strumieñ bajtów)
    \item Biblioteki TOS dostarczaj± swoje komponenty z~us³ugami wy¿szego poziomu (np. transmisja pakietowa)
    \item Aplikacje dostarczaj± modu³y implementuj±ce logikê aplikacji
  \end{itemize}
  Elementy te zbierane s± razem i~³±czone za pomoc± konfiguracji, w~efekcie czego uzyskujemy
  dzia³aj±cy program.
\end{frame}

\begin{frame}{Przyk³ad: wy¶wietlacz PC -> LCD}
  To jest aplikacja!

  \tt{components MainC, SerialActiveMessageC;}

  \tt{components PlatformLCDC, PC2LCDAppP; }

  \tt{PC2LCDAppP.Boot      -> MainC; }

  \tt{PC2LCDAppP.AMSend    -> SerialActiveMessageC; }

  \tt{PC2LCDAppP.LCDDriver -> PlatformLCDC; }
\end{frame}

\begin{frame}{Case study: Virtualized timers}
  Pierwszy przyk³ad - tyle zegarów ile tylko chcemy!
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Problem:
  \begin{figure} [ht]
    \centering
    \includegraphics[width=\linewidth]{problem.png}
  \end{figure}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Problem:
  \begin{itemize}
    \item Kilka szyn komunikacyjnych
    \item Ka¿da ma kilka urz±dzeñ, ale obs³ugiwaæ mo¿e tylko jedno
    \item Wszystko trzeba jeszcze w³±czaæ i~wy³±czaæ
  \end{itemize}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  \begin{itemize}
    \item Trzeba rozwi±zaæ konflikty o~zasoby
    \item ale równie¿ oszczêdzaæ energiê, gdy zasób nie jest u¿ywany
  \end{itemize}
  Okazuje siê, ¿e oba problemy s± maj± wspólne rozwi±zanie.
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}

  \tt{interface Resource \{ }

  \tt{ \hspace{4 mm} async command error\_t request(); }

  \tt{ \hspace{4 mm} event void granted(); }

  \tt{ \hspace{4 mm} async command error\_t release(); }

  \tt{ \hspace{4 mm} async command bool isOwner(); }

  \tt{ \} }

\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  Rozwi±zanie:
  \begin{figure} [ht]
    \centering
    \includegraphics[height=0.7 \textheight]{rozwiazanie.png}
  \end{figure}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  \begin{itemize}
    \item Klient prosi o zasób
    \item Arbiter rozpatruje zapytania
    \item Je¶li urz±dzenie wy³±czone, konfiguruje je
    \item Power manager dba by procesor nie przeszed³ w zbyt g³êboki stan u¶pienia
    \item Klient dostaje urz±dzenie gotowe do dzia³ania
    \item Potem je zwalnia
    \item Gdy zabraknie ju¿ rz±dañ urz±dzenie jest wy³±czane
  \end{itemize}
\end{frame}

\begin{frame}{Case study: Integrated concurency and power management}
  \begin{itemize}
    \item Os±ga to efektywno¶æ blisk± 99\% rêcznie dostrojonym rozwi±zaniom.
    \item Pamiêtajmy, ¿e chcemy mo¿liwie skróciæ czas gdy pr±do¿erne urz±dzenia
      s± w³±czone, wiêc ci±gle co¶ w³±czamy i wy³±czamy - a tu takiego kodu
      prawie nie ma
  \end{itemize}
\end{frame}

\begin{frame}{Case study: Zordon App}
  \tt{
  components MainC, ZordonP as App;

  components PlatformLCDC;

  components new AMSenderC(RANGER\_CALL\_MSG);

  components new AMReceiverC(RANGER\_CALL\_MSG);

  components ActiveMessageC;
 
  App.Boot -> MainC;

  App.LCDDriver -> PlatformLCDC;

  App.AMSend -> AMSenderC;

  App.Receive -> AMReceiverC;

  App.AMControl -> ActiveMessageC;
  }
\end{frame}

\begin{frame}{Case study: Zordon App}
  \tt {
  components UpButtonC, DownButtonC;

  components BacklightButtonC, StarButtonC;

  App.NextNameButton -> UpButtonC;

  App.PowerButton -> BacklightButtonC;

  App.PrevNameButton -> DownButtonC;

  App.SendButton -> StarButtonC;

  components BeeperC;

  App.Beeper -> BeeperC;

  components TopLCDBlinkerC;

  App.TopBlinkerControl -> TopLCDBlinkerC;

  App.TopLCDBlinker -> TopLCDBlinkerC;
  }
\end{frame}

\begin{frame}{S³owo o~debugowaniu}
  \begin{itemize}
    \item Wa¿nym probleme jest to, ¿e aplikacje jest do¶æ trudno debugowaæ
    \item Mamy funkcjê printf
    \item Dla Chronos'a dzia³a nawet debugger w~Eclipse!
  \end{itemize}
  Najczêstrzy przypadek jest i~tak taki: Mia³a ¶wieciæ dioda. Wgrywamy - nie
  ¶wieci. I~co?

  Piotr opowie wiêcej jak temu zaradziæ.
\end{frame}


% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\end{document}

